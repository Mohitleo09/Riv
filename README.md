# Rival â€” Modern Blog Platform

> A production-grade, full-stack blog platform built for minimalist, long-form creative writing. Designed with a focus on architecture, type safety, and a premium user experience.

ğŸŒ **Live App**: [riv-production.up.railway.app](https://riv-production.up.railway.app)

---

## âœ¨ What's New (Latest Features)

### ğŸ”¥ Trending Tags Sidebar *(New!)*
The feed page now has a smart sidebar that **automatically extracts keywords** from all blog posts and ranks them by popularity (frequency + likes). Clicking any tag instantly filters the feed â€” no page reload needed.

### ğŸ“Š Platform Stats Widget *(New!)*
A live statistics panel on the feed sidebar shows the total number of posts, unique writers, and total likes across the platform.

### â± Reading Time Estimator *(New!)*
Every blog card now shows an estimated reading time (e.g., "3 min read") calculated from the word count. Writers also see a **live reading time indicator** while typing their post.

### âš¡ Writer Insights on Profile *(New!)*
The Profile page now has a dedicated analytics section with 3 cards:
- **Writing Streak** â€” counts how many consecutive days you've been active.
- **Engagement Engine** â€” a weighted score (Comments are 3Ã— more valuable than Likes).
- **Global Rank** â€” shows your standing among the writers on the platform.

### ğŸ›¡ï¸ Safe Blog Deletion *(Fixed!)*
Deleting a blog that has likes or comments no longer causes a server error. The system now safely removes all related data (likes, comment likes, comments) in the correct order before deleting the blog.

### ğŸš€ Instant Blog Publishing *(Fixed!)*
Publishing a blog no longer times out. The background summary generator (AI task) now runs asynchronously â€” you get redirected immediately after publishing, and the summary is generated quietly in the background.

---

## ğŸš€ Key Features

| Feature | Description |
|---|---|
| **Dual Authentication** | Access token + Refresh token strategy with rotation |
| **Auto-Saving Editor** | Edits are saved to the server every second automatically |
| **Activity Pulse** | A heatmap showing your writing activity over the last 30 days |
| **Trending Tags** | AI-extracted keywords that filter the feed instantly |
| **Infinite Scroll Feed** | Posts load automatically as you scroll down |
| **Real-time Search** | Debounced search filters posts as you type |
| **Optimistic UI** | Likes update instantly without waiting for the server |
| **Comments & Replies** | Nested comments with their own like system |
| **Image Support** | Upload images to your posts (stored as Base64) |
| **Reading Time** | Estimated reading time shown on every post |
| **Writer Insights** | Streak counter, engagement score, and rank on your profile |
| **RBAC** | Role-Based Access Control (User / Admin) |
| **Background Jobs** | Blog summaries are generated by a BullMQ worker in the background |
| **Rate Limiting** | API is protected against abuse with a per-IP rate limiter |
| **Performance Logging** | Structured logging with Pino for production monitoring |

---

## ğŸ—ï¸ Tech Stack

### Backend (NestJS)
- **NestJS** with modular architecture (`auth`, `blogs`, `users`)
- **Prisma** for type-safe database queries
- **PostgreSQL** for the primary database
- **BullMQ + Redis** for background job processing
- **Passport + JWT** for authentication
- **Pino** for structured production logging
- **Throttler** for request rate limiting

### Frontend (Next.js 15)
- **Next.js 15** with App Router
- **TanStack Query (React Query)** for server state management and optimistic UI
- **Framer Motion** for smooth, premium page transitions
- **Tailwind CSS v4** for styling
- **Axios** for HTTP requests (with automatic token refresh interceptors)

---

## ğŸ Local Development Setup

### 1. Requirements
Make sure you have:
- **Node.js v20+**
- **Docker Desktop** (for running Postgres & Redis locally)

### 2. Create a `.env` file in the root directory
```env
# PostgreSQL (the local docker container)
DATABASE_URL="postgresql://user:password@localhost:5432/rival_db?schema=public"

# Redis (the local docker container)
REDIS_HOST="localhost"
REDIS_PORT=6379

# A secret key for signing JWTs â€” make this long and random
JWT_SECRET="your-super-secret-key-min-32-chars"

# The frontend will call this URL for all API requests
NEXT_PUBLIC_API_URL="http://localhost:3001"
```

### 3. Install & Run
```bash
# Install all dependencies
npm install

# Start the Postgres & Redis docker containers
docker-compose up -d

# Push the database schema to your local Postgres
npm run prisma:generate
npm run prisma:push

# Start both the Next.js frontend and NestJS backend at once
npm run dev
```

- **Frontend**: [http://localhost:3000](http://localhost:3000)
- **API Server**: [http://localhost:3001](http://localhost:3001)

---

## â˜ï¸ Production Deployment (Railway)

The application is deployed as a **single unified service** on [Railway](https://railway.app/), which runs both the Next.js frontend and NestJS backend simultaneously.

### Services Required
- **PostgreSQL** (Railway Add-on)
- **Redis** (Railway Add-on)

### Environment Variables (set in Railway Dashboard)
| Variable | Value |
|---|---|
| `DATABASE_URL` | Reference â†’ `${{Postgres.DATABASE_URL}}` |
| `REDIS_URL` | Reference â†’ `${{Redis.REDIS_URL}}` |
| `JWT_SECRET` | Your secret key |
| `BACKEND_PORT` | `3001` |
| `NODE_ENV` | `production` |

### How It Works in Production
Next.js is configured with a **proxy rewrite rule** (`next.config.ts`) so that any request to `/api/*` from the browser is automatically forwarded to the NestJS server running internally on port `3001`. This keeps the entire app accessible through a single domain.

---

## ğŸ“ Project Structure

```
rival/
â”œâ”€â”€ prisma/
â”‚   â””â”€â”€ schema.prisma         # Database models (User, Blog, Like, Comment)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/                  # Next.js App Router pages
â”‚   â”‚   â”œâ”€â”€ feed/             # Public feed with trending sidebar
â”‚   â”‚   â”œâ”€â”€ blog/[slug]/      # Single blog post view
â”‚   â”‚   â”œâ”€â”€ dashboard/        # Writer's content management
â”‚   â”‚   â””â”€â”€ profile/          # User profile with Writer Insights
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ blog/             # BlogCard, LikeButton, TrendingTags, etc.
â”‚   â”‚   â””â”€â”€ ui/               # ActivityHeatmap, BlurImage, Skeleton, etc.
â”‚   â”œâ”€â”€ hooks/                # Reusable React hooks (useLikeBlog, useDebounce)
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ api.ts            # Axios client with auth interceptors
â”‚   â”‚   â”œâ”€â”€ types.ts          # Shared TypeScript types
â”‚   â”‚   â””â”€â”€ utils.ts          # cn(), calculateReadingTime(), calculateStreak()
â”‚   â”œâ”€â”€ auth/                 # NestJS auth module (login, register, JWT)
â”‚   â”œâ”€â”€ blogs/                # NestJS blogs module (CRUD, likes, comments)
â”‚   â””â”€â”€ users/                # NestJS users module
â”œâ”€â”€ next.config.ts            # Next.js config with /api proxy rewrite
â”œâ”€â”€ docker-compose.yml        # Local Postgres + Redis services
â””â”€â”€ package.json              # Unified scripts for both frontend and backend
```

---

## âš–ï¸ Design Tradeoffs

1. **Unified Monorepo vs. Separate Packages**: Chosen for simplicity â€” no complex workspace configuration needed. Shared types between frontend and backend "just work."
2. **Prisma vs. Raw SQL**: Prisma was chosen for fast development and safe relationship management (cascading deletes, unique constraints). Raw SQL would be faster for extremely high traffic.
3. **Base64 Images vs. CDN**: Images are stored as Base64 strings directly in the database to avoid requiring a cloud storage setup. In a real production scale scenario, this would be replaced with S3 + CloudFront.

---

## ğŸ“ˆ What I Would Improve Next

1. **Rich Text Editor**: Replace the `<textarea>` with a block-based editor like **Tiptap** for a premium writing experience (bold, headers, code blocks).
2. **SSR for SEO**: Move the public feed and blog pages to Server-Side Rendering so Google can index the content properly.
3. **HttpOnly Cookies**: Move JWTs from `localStorage` to `HttpOnly Cookies` to prevent XSS token theft.
4. **Playwright E2E Tests**: Add end-to-end testing for the critical user flows (register â†’ write â†’ publish â†’ like).
5. **Real AI Summaries**: Integrate an LLM API (OpenAI/Gemini) to generate actual content summaries instead of just copying content.

---

## ğŸ”¢ Scaling to 1 Million Users

1. **Read Replicas**: Add PostgreSQL read replicas to distribute the heavy read load of the public feed.
2. **Redis Caching**: Cache the top 100 most-viewed blog posts in Redis to avoid hitting the database on every request.
3. **Edge Caching**: Use Vercel/Cloudflare to cache public blog URLs at the CDN edge for near-zero latency reads.
4. **S3 + CloudFront**: Move image storage out of the database and into Amazon S3, served via CDN.
5. **Kubernetes**: Containerize the NestJS backend and deploy it with an auto-scaler to handle traffic spikes.
6. **Separate Workers**: Run the BullMQ workers in their own dedicated containers so background jobs don't compete with the API for resources.
