# Rival â€” Modern Blog Platform

> A production-grade, full-stack blog platform built for minimalist, long-form creative writing. Designed with a focus on architecture, type safety, and a premium user experience.

ğŸŒ **Live App**: [riv-production.up.railway.app](https://riv-production.up.railway.app)

---

### âœ¨ What's New (Latest Features)

### ğŸŒ Live Trends & Hashtags *(New!)*
The feed sidebar now features live, production-ready trends fetched directly from **Reddit r/all** and **Hacker News**. Individual **hashtag chips** are dynamically generated from current viral topics, allowing you to filter the feed with one click.

### ğŸ˜Š Premium Emoji Picker *(New!)*
Implemented a Twitter/Slack-style emoji picker using `@emoji-mart`. It features:
- **600+ emojis** across all standard categories (Flags, Food, Travel, etc.)
- **Search engine** with keyword indexing.
- **Recently used** tracking.
- **Cursor-aware insertion** in both title and content fields.

### ğŸ“Š Clean Profile Stats *(New!)*
Replaced bulky cards with a **minimalist horizontal stats bar** on the profile page. It tracks your Posts, Likes, Streak, and Engagement Score at a glance in a clean, unified row.

### â± Reading Time Estimator
Every blog card shows an estimated reading time. Writers also see a **live reading time indicator** while typing their post.

### ğŸ›¡ï¸ Safe Blog Deletion
Deleting a blog now safely cascades to likes and comments, preventing 500 errors.

### ğŸš€ Instant Blog Publishing
Publishing is now immediate. AI summary generation moved to a background worker to prevent timeouts.

---

## ğŸš€ Key Features

| Feature | Description |
|---|---|
| **Dual Authentication** | Access token + Refresh token strategy with rotation |
| **Auto-Saving Editor** | Edits are saved to the server every second automatically |
| **Activity Pulse** | A heatmap showing your writing activity over the last 30 days |
| **Trending Tags** | AI-extracted keywords that filter the feed instantly |
| **Infinite Scroll Feed** | Posts load automatically as you scroll down |
| **Real-time Search** | Debounced search filters posts as you type |
| **Optimistic UI** | Likes update instantly without waiting for the server |
| **Comments & Replies** | Nested comments with their own like system |
| **Image Support** | Upload images to your posts (stored as Base64) |
| **Reading Time** | Estimated reading time shown on every post |
| **Writer Insights** | Streak counter, engagement score, and rank on your profile |
| **RBAC** | Role-Based Access Control (User / Admin) |
| **Background Jobs** | Blog summaries are generated by a BullMQ worker in the background |
| **Rate Limiting** | API is protected against abuse with a per-IP rate limiter |
| **Performance Logging** | Structured logging with Pino for production monitoring |

---

## ğŸ—ï¸ Tech Stack

### Backend (NestJS)
- **NestJS** with modular architecture (`auth`, `blogs`, `users`)
- **Prisma** for type-safe database queries
- **PostgreSQL** for the primary database
- **BullMQ + Redis** for background job processing
- **Passport + JWT** for authentication
- **Pino** for structured production logging
- **Throttler** for request rate limiting

### Frontend (Next.js 15)
- **Next.js 15** with App Router
- **TanStack Query (React Query)** for server state management and optimistic UI
- **Framer Motion** for smooth, premium page transitions
- **Tailwind CSS v4** for styling
- **Axios** for HTTP requests (with automatic token refresh interceptors)

---

## ğŸ Local Development Setup

### 1. Requirements
Make sure you have:
- **Node.js v20+**
- **Docker Desktop** (for running Postgres & Redis locally)

### 2. Create a `.env` file in the root directory
```env
# PostgreSQL (the local docker container)
DATABASE_URL="postgresql://user:password@localhost:5432/rival_db?schema=public"

# Redis (the local docker container)
REDIS_HOST="localhost"
REDIS_PORT=6379

# A secret key for signing JWTs â€” make this long and random
JWT_SECRET="your-super-secret-key-min-32-chars"

# The frontend will call this URL for all API requests
NEXT_PUBLIC_API_URL="http://localhost:3001"
```

### 3. Install & Run
```bash
# Install all dependencies
npm install

# Start the Postgres & Redis docker containers
docker-compose up -d

# Push the database schema to your local Postgres
npm run prisma:generate
npm run prisma:push

# Start both the Next.js frontend and NestJS backend at once
npm run dev
```

- **Frontend**: [http://localhost:3000](http://localhost:3000)
- **API Server**: [http://localhost:3001](http://localhost:3001)

---

## â˜ï¸ Production Deployment (Railway)

The application is deployed as a **single unified service** on [Railway](https://railway.app/), which runs both the Next.js frontend and NestJS backend simultaneously.

### Services Required
- **PostgreSQL** (Railway Add-on)
- **Redis** (Railway Add-on)

### Environment Variables (set in Railway Dashboard)
| Variable | Value |
|---|---|
| `DATABASE_URL` | Reference â†’ `${{Postgres.DATABASE_URL}}` |
| `REDIS_URL` | Reference â†’ `${{Redis.REDIS_URL}}` |
| `JWT_SECRET` | Your secret key |
| `BACKEND_PORT` | `3001` |
| `NODE_ENV` | `production` |

### How It Works in Production
Next.js is configured with a **proxy rewrite rule** (`next.config.ts`) so that any request to `/api/*` from the browser is automatically forwarded to the NestJS server running internally on port `3001`. This keeps the entire app accessible through a single domain.

---

## ğŸ“ Project Structure

```
rival/
â”œâ”€â”€ prisma/
â”‚   â””â”€â”€ schema.prisma         # Database models (User, Blog, Like, Comment)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/                  # Next.js App Router pages
â”‚   â”‚   â”œâ”€â”€ feed/             # Public feed with trending sidebar
â”‚   â”‚   â”œâ”€â”€ blog/[slug]/      # Single blog post view
â”‚   â”‚   â”œâ”€â”€ dashboard/        # Writer's content management
â”‚   â”‚   â””â”€â”€ profile/          # User profile with Writer Insights
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ blog/             # BlogCard, LikeButton, TrendingTags, etc.
â”‚   â”‚   â””â”€â”€ ui/               # ActivityHeatmap, BlurImage, Skeleton, etc.
â”‚   â”œâ”€â”€ hooks/                # Reusable React hooks (useLikeBlog, useDebounce)
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ api.ts            # Axios client with auth interceptors
â”‚   â”‚   â”œâ”€â”€ types.ts          # Shared TypeScript types
â”‚   â”‚   â””â”€â”€ utils.ts          # cn(), calculateReadingTime(), calculateStreak()
â”‚   â”œâ”€â”€ auth/                 # NestJS auth module (login, register, JWT)
â”‚   â”œâ”€â”€ blogs/                # NestJS blogs module (CRUD, likes, comments)
â”‚   â””â”€â”€ users/                # NestJS users module
â”œâ”€â”€ next.config.ts            # Next.js config with /api proxy rewrite
â”œâ”€â”€ docker-compose.yml        # Local Postgres + Redis services
â””â”€â”€ package.json              # Unified scripts for both frontend and backend
```

---

## âš–ï¸ Design Tradeoffs

1. **Unified Monorepo vs. Separate Packages**: Chosen for simplicity â€” no complex workspace configuration needed. Shared types between frontend and backend "just work."
2. **Prisma vs. Raw SQL**: Prisma was chosen for fast development and safe relationship management (cascading deletes, unique constraints). Raw SQL would be faster for extremely high traffic.
3. **Base64 Images vs. CDN**: Images are stored as Base64 strings directly in the database to avoid requiring a cloud storage setup. In a real production scale scenario, this would be replaced with S3 + CloudFront.

---

## ğŸ“ˆ What I Would Improve Next

1. **Rich Text Editor**: Replace the `<textarea>` with a block-based editor like **Tiptap** for a premium writing experience (bold, headers, code blocks).
2. **SSR for SEO**: Move the public feed and blog pages to Server-Side Rendering so Google can index the content properly.
3. **HttpOnly Cookies**: Move JWTs from `localStorage` to `HttpOnly Cookies` to prevent XSS token theft.
4. **Playwright E2E Tests**: Add end-to-end testing for the critical user flows (register â†’ write â†’ publish â†’ like).
5. **Real AI Summaries**: Integrate an LLM API (OpenAI/Gemini) to generate actual content summaries instead of just copying content.

---

## ğŸ”¢ Scaling to 1 Million Users

1. **Read Replicas**: Add PostgreSQL read replicas to distribute the heavy read load of the public feed.
2. **Redis Caching**: Cache the top 100 most-viewed blog posts in Redis to avoid hitting the database on every request.
3. **Edge Caching**: Use Vercel/Cloudflare to cache public blog URLs at the CDN edge for near-zero latency reads.
4. **S3 + CloudFront**: Move image storage out of the database and into Amazon S3, served via CDN.
5. **Kubernetes**: Containerize the NestJS backend and deploy it with an auto-scaler to handle traffic spikes.
6. **Separate Workers**: Run the BullMQ workers in their own dedicated containers so background jobs don't compete with the API for resources.
